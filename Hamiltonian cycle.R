Hamilton <- matrix(c(0,1,0,1,1,1,0,0,
                     1,0,1,0,1,1,0,0,
                     0,1,0,1,0,0,1,1,
                     1,0,1,0,0,0,1,1,
                     1,1,0,0,0,1,0,1,
                     1,1,0,0,1,0,1,0,
                     0,0,1,1,0,1,0,1,
                     0,0,1,1,1,0,1,0), nrow=8,ncol=8, byrow=TRUE)

cycle <- function(G){
  n <- nrow(G)
  q <- 1:n  #задаем случайную очередь
  for(i in 1:(n*n-n)){
    if(G[q[1],q[2]]!=0){  #если между первой и второй вершиной в очереди есть ребро, первую перемещаем в конец
      x <- q[1]
      q <- q[-1]
      q <- c(q,x)
    }else{
      for(f in 3:(n-1)){ #иначе находим такую вершину key, которая 1) смежна с первой в очереди, 2) следующая в очереди за ней смежна со второй в очереди
        if(G[q[1],q[f]]!=0 && G[q[2],q[f+1]]!=0){
          key <- f
          break
        }
      }
      for(j in 0:n){
        if((2+j)<(key-j)){  #пока справедливо это неравенство, будем менять вершины в очереди местами
          h <- q[2+j]
          q[2+j] <- q[key-j]
          q[key-j] <- h
        }
      }
      x <- q[1]  #первую в очереди вершину перемещаем в конец
      q <- q[-1]
      q <- c(q,x) 
    }
  }
  return(q)
}
print(cycle(Hamilton))